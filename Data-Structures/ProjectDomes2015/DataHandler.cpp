#pragma once 

#include "DataHandler.h"
#include "Observer.h"

#include <sstream>
#include <fstream>
#include <string>
#include <cstdlib>

#define CSV_DEL ';'

using namespace std;
extern int ALLOC_FACTOR;

/**
*  Default Consructor
**/
DataHandler::DataHandler() {
	dataUpdated = false;
	deletedIndex = insertedIndex = -1;
}


/**
*  Deallocating heap memory
**/
DataHandler::~DataHandler() {
	size_t size = companies.size();
	for (size_t i = 0; i < companies.size(); ++i) {
		delete companies[i];
	}
	companies.clear();
}


/**
*  Deletes all the entries
*  Notifies all the observers of the change
**/
void DataHandler::dropAllEntries() {
	size_t size = companies.size();
	if (size) {
		dataUpdated = true;
		for (size_t i = 0; i < size; ++i) {
			delete companies[i];
		}
		companies.clear();
		notifyAllObservers(DROP);
	}
}


/**
*  Returns the capacity of the Companies vector
**/
size_t DataHandler::getCapacity() const {
	return companies.capacity();
}


/**
*  Returns the size of the Companies Vector
**/
size_t DataHandler::getSize() const {
	return companies.size();
}


/**
*  Returns if an update action was performed
**/
bool DataHandler::isUpadated() const {
	return dataUpdated;
}


/**
*  Sets the new capacity of the vector
*  Notifies all the observers of the change
**/
void DataHandler::setCapacity(int size) {
	companies.reserve(size + ALLOC_FACTOR);
}


/**
*  Insert a new Company to the vector
*  Notifies all the observers of the change
**/
void DataHandler::insertCompany(Company *newCompany) {
	dataUpdated = true;
	insertedIndex = companies.size();
	companies.push_back(newCompany);
	notifyAllObservers(INSERT);
}


/**
*  Inserts a new Company to the vector
*  without notifing the observers, for faster insert
**/
void DataHandler::insertOnly(Company *newCompany) {
	dataUpdated = true;
	companies.push_back(newCompany);
}


/**
*  Removes a company from the vector
*  Notifies all the observers of the change
**/
bool DataHandler::removeCompany(int id) {

	size_t i , compSize = companies.size();
	deletedIndex = -1;

	// Serial search
	for (i = 0; i < compSize; ++i) {
		if (companies[i]->id == id) {
			deletedIndex = i;
			break;
		}
	}

	if (deletedIndex < 0) {
		return false;
	}

	notifyAllObservers(REMOVE);
	delete companies[deletedIndex];
	companies.erase(companies.begin() + deletedIndex);
	dataUpdated = true;
	return true;
}


/**
*  Loads the supplied .csv formatted file into memory using the format bellow
*  id; title; summary; numberOfEmployees; employee1; employee2; employee3; ….; employee7
**/
void DataHandler::loadFromFile() {

	Company *newComp;
	string line, cell, firstname, lastname;
	size_t rowCounter, cellCounter, totalEmp;
	

	ifstream datafile(file);
	if (datafile.is_open() && getline(datafile, line)) {
		// De alocate the memory
		dropAllEntries();

		// Load the rows of the input file and alloc the memory
		size_t rows = atoi(line.c_str());
		setCapacity((rows > 0) ? rows : 0);

		// Foreach row, split it into cells
		rowCounter = 0;
		while (rowCounter < rows && getline(datafile, line))
		{
			stringstream  lineStream(line);
			cellCounter = totalEmp = 0;
			newComp = new Company();

			// While we have an available cell
			while (getline(lineStream, cell, CSV_DEL)) {
				switch (++cellCounter) {
				case 1:
					newComp->id = atoi(cell.c_str());
					break;
				case 2:
					newComp->title = cell.substr(0, Company::TITLE_LEN);
					break;
				case 3:
					newComp->summary = cell.substr(0, Company::SUMRY_LEN);
					break;
				case 4:
					totalEmp = atoi(cell.c_str());
					break;
				default:
					if (newComp->numberOfEmployees < totalEmp) {
						stringstream helper(cell);
						helper >> firstname >> lastname;
						newComp->insertEmployee(
							new Employee(firstname.substr(0, Employee::FNAME_LEN),
							lastname.substr(0, Employee::LNAME_LEN))
						);
					}
				}
			}
			// Insert new company to the vector
			insertOnly(newComp);
			++rowCounter;
		}
		datafile.close();
		dataUpdated = false;  // Disable the updated flag
		notifyAllObservers(IMPORT);
		setFileError(NOERROR);
	}
	else {
		// File could not be loaded, or bad format
		setFileError(READ);
		setCapacity(0);
	}
}


/**
*  Returns the file error code
**/
int DataHandler::getFileError() const {
	return fileErrorCode;
}


/**
*  Sets the error code
**/
void DataHandler::setFileError(FileError error) {
	fileErrorCode = error;
}


/**
*   Return the error message generated by the 
*   last proccess including files
**/
string DataHandler::getFileErrorMsg() const {

	switch (fileErrorCode) {
	case WRITE:
		return "Unable to create/overwrite output file";
	case READ:
		return "File could not be loaded, or bad file format";
	default:
		return "";
	}
}


/**
*  Sets the filename of the I/O file
**/
void DataHandler::setFilename(char *file) {
	this->file = file;
}


/**
*  Saves any relevant changes to the file
**/
void DataHandler::writeToFile() {

	if (!dataUpdated) {
		return;
	}
	ofstream datafile(file);
	size_t i, j, empNum, size = companies.size();;

	if (datafile.is_open()) {
		datafile << size << CSV_DEL;
		for (i = 0; i < size; ++i) {
			datafile << endl;
			datafile << companies[i]->id << CSV_DEL;
			datafile << companies[i]->title << CSV_DEL;
			datafile << companies[i]->summary << CSV_DEL;
			empNum = companies[i]->employees.size();
			datafile << empNum << CSV_DEL;

			for (j = 0; j < empNum; ++j) {
				datafile << companies[i]->employees[j]->firstName << " ";
				datafile << companies[i]->employees[j]->lastName << CSV_DEL;
			}
		}
		datafile.close();
		dataUpdated = false;
		setFileError(NOERROR);
	}
	else {
		setFileError(WRITE);
	}
}


/**
*  Attach a new observer
**/
void DataHandler::attach(Observer *observer){
	observers.push_back(observer);
}


/**
*  Supplied the event mode notifies all the observers
**/
void DataHandler::notifyAllObservers(Mode modeType) const {
	size_t i, obserSize = observers.size();
	for (i = 0; i < obserSize; ++i) {
		switch (modeType) {
		case Mode::INSERT:
			observers[i]->insert();
			break;
		case Mode::REMOVE:
			observers[i]->remove();
			break;
		case Mode::IMPORT:
			observers[i]->import();
			break;
		case Mode::DROP:
			observers[i]->drop();
			break;
		}
	}
}


/**
*  Returns the index of the inserted object
**/
size_t DataHandler::getInsIndex() const {
	return insertedIndex;
}


/**
*  Returns the index of the deleted object
**/
size_t DataHandler::getDelIndex() const {
	return deletedIndex;
}